<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è·å…°è¯­A2è¯æ±‡å­¦ä¹ ç³»ç»Ÿ - LINK+ å®Œæ•´è¯æ±‡è¡¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #6B73FF 0%, #000DFF 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 30px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
        }

        h1 {
            color: #333;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #666;
            font-size: 1.2em;
        }

        .controls {
            background: white;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .stats-bar {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .stat-item {
            text-align: center;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 10px;
            min-width: 150px;
            margin: 5px;
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .filter-section {
            margin-bottom: 20px;
        }

        .filter-label {
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
            display: block;
        }

        .filter-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .filter-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            background: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }

        .filter-btn:hover {
            background: #667eea;
            color: white;
            transform: translateY(-2px);
        }

        .filter-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .search-section {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .search-box {
            flex: 1;
            padding: 12px 20px;
            border: 2px solid #e0e0e0;
            border-radius: 25px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .search-box:focus {
            outline: none;
            border-color: #667eea;
        }

        .mode-toggle {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .mode-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 10px;
            background: #f0f0f0;
            color: #333;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .vocabulary-container {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .cards-view {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
        }

        .word-card {
            background: white;
            border: 2px solid #e0e0e0;
            padding: 20px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            position: relative;
            will-change: transform, box-shadow;
        }

        .word-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
            border-color: #667eea;
        }

        .word-card.learned {
            border-color: #4caf50;
            background: linear-gradient(to bottom right, white 95%, #4caf50 5%);
        }

        .word-card.flipped {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: transparent;
        }

        .theme-tag {
            position: absolute;
            bottom: 8px;
            left: 8px;
            padding: 3px 8px;
            background: #f0f0f0;
            border-radius: 10px;
            font-size: 11px;
            color: #666;
        }

        .word-card.flipped .theme-tag {
            background: rgba(255,255,255,0.2);
            color: white;
        }

        .dutch-word {
            font-size: 1.3em;
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }

        .word-card.flipped .dutch-word {
            color: white;
        }

        .speak-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 50%;
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.3s;
        }

        .speak-btn:hover {
            background: #667eea;
            color: white;
            transform: scale(1.1);
        }

        .word-card.flipped .speak-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .word-card.flipped .speak-btn:hover {
            background: rgba(255, 255, 255, 0.4);
        }

        /* æ›´å¤šæŒ‰é’®æ ·å¼ */
        .more-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 50%;
            background: transparent;
            color: #999;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.3s;
            z-index: 2;
        }

        .more-btn:hover {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
        }

        .word-card.flipped .more-btn {
            color: rgba(255, 255, 255, 0.8);
        }

        .word-card.flipped .more-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        /* è¯¦ç»†ä¿¡æ¯æ¨¡æ€æ¡†æ ·å¼ */
        .detail-modal {
            width: 700px;
            max-width: 90vw;
            height: 600px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }

        #detailContent {
            overflow-y: auto;
            overflow-x: hidden;
            flex: 1;
            padding-right: 10px;
            /* Firefoxæ»šåŠ¨æ¡ */
            scrollbar-width: thin;
            scrollbar-color: #888 #f1f1f1;
        }

        /* è‡ªå®šä¹‰æ»šåŠ¨æ¡æ ·å¼ */
        #detailContent::-webkit-scrollbar {
            width: 8px;
        }

        #detailContent::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        #detailContent::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }

        #detailContent::-webkit-scrollbar-thumb:hover {
            background: #667eea;
        }

        /* é€‰è¯ç¿»è¯‘æ ·å¼ */
        .translation-popup {
            position: fixed;
            display: none;
            background: white;
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 12px 16px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            z-index: 10000;
            max-width: 300px;
            animation: fadeIn 0.2s ease;
        }

        .translation-popup.active {
            display: block;
        }

        .translation-content {
            display: flex;
            flex-direction: column;
            gap: 8px;
            position: relative;
        }

        .translation-word {
            font-size: 18px;
            font-weight: bold;
            color: #667eea;
            padding-right: 40px;
            margin-right: 5px;
        }

        .translation-meaning {
            font-size: 14px;
            color: #333;
            line-height: 1.4;
        }

        .translation-speak {
            position: absolute;
            top: -2px;
            right: -2px;
            background: #667eea;
            border: none;
            border-radius: 4px;
            padding: 2px 6px;
            cursor: pointer;
            font-size: 14px;
            color: white;
            line-height: 1;
        }

        .translation-speak:hover {
            background: #5a67d8;
        }

        /* å¯é€‰ä¸­æ–‡æœ¬æ ·å¼ */
        .selectable-text {
            user-select: text;
            cursor: text;
        }

        .selectable-text::selection {
            background: #b4d5ff;
            color: #000;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-5px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .detail-header {
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 20px;
            margin-bottom: 25px;
            position: sticky;
            top: 0;
            background: white;
            z-index: 1;
        }

        .detail-word {
            font-size: 2.5em;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 10px;
        }

        .detail-pronunciation {
            font-size: 1.2em;
            color: #999;
            margin-bottom: 5px;
        }

        .detail-meaning {
            font-size: 1.4em;
            color: #555;
        }

        .detail-section {
            margin-bottom: 25px;
        }

        .detail-section h3 {
            color: #667eea;
            font-size: 1.2em;
            margin-bottom: 12px;
            border-bottom: 1px solid #e8e8e8;
            padding-bottom: 8px;
        }

        .detail-info {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }

        .detail-tag {
            padding: 6px 12px;
            background: #f5f5f5;
            border-radius: 15px;
            font-size: 14px;
            color: #666;
        }

        .conjugation-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .conjugation-table th {
            background: #f8f8f8;
            padding: 10px;
            text-align: left;
            font-weight: 600;
            color: #555;
        }

        .conjugation-table td {
            padding: 10px;
            border-bottom: 1px solid #f0f0f0;
        }

        .conjugation-table tr:hover {
            background: #f9f9f9;
        }

        .example-sentence {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 8px 0;
            border-left: 3px solid #667eea;
        }

        .example-dutch {
            font-size: 1.1em;
            color: #333;
            margin-bottom: 8px;
        }

        .example-english {
            font-size: 1em;
            color: #666;
            font-style: italic;
        }

        .english-meaning {
            color: #666;
            font-size: 1em;
            display: none;
        }

        .word-card.flipped .english-meaning {
            display: block;
            color: white;
        }

        .list-view {
            display: none;
        }

        .list-view.active {
            display: block;
        }

        .cards-view.active {
            display: grid;
        }

        .vocabulary-table {
            width: 100%;
            border-collapse: collapse;
        }

        .vocabulary-table th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px;
            text-align: left;
            position: sticky;
            top: 0;
        }

        .vocabulary-table td {
            padding: 10px 12px;
            border-bottom: 1px solid #e0e0e0;
        }

        .vocabulary-table tr:hover {
            background: #f5f5f5;
        }

        .theme-badge {
            padding: 3px 8px;
            background: #e8f4f8;
            border-radius: 5px;
            font-size: 12px;
            color: #2196F3;
        }

        .task-badge {
            padding: 3px 8px;
            background: #fff3e0;
            border-radius: 5px;
            font-size: 12px;
            color: #ff9800;
        }

        .action-buttons {
            position: fixed;
            bottom: 30px;
            right: 30px;
            display: flex;
            gap: 10px;
        }

        .action-btn {
            padding: 15px;
            border-radius: 50%;
            background: white;
            border: none;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: all 0.3s;
            font-size: 20px;
        }

        .action-btn:hover {
            transform: scale(1.1);
        }

        @media (max-width: 768px) {
            .cards-view {
                grid-template-columns: 1fr;
            }

            h1 {
                font-size: 1.8em;
            }

            .vocabulary-table {
                font-size: 14px;
            }

            .detail-modal {
                height: 500px;
                max-height: 70vh;
            }

            .detail-word {
                font-size: 2em;
            }
        }

        /* æ¨¡æ€æ¡†æ ·å¼ */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            animation: fadeIn 0.3s ease;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 600px;
            width: 90%;
            position: relative;
            animation: slideIn 0.3s ease;
        }

        .modal-content.detail-modal {
            padding: 30px;
            padding-top: 50px;
        }

        .modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            font-size: 30px;
            cursor: pointer;
            color: #999;
            transition: color 0.3s;
        }

        .modal-close:hover {
            color: #333;
        }

        .random-word-card {
            background: white;
            border: 2px solid #667eea;
            color: #333;
            padding: 60px 40px;
            border-radius: 15px;
            text-align: center;
            min-height: 300px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            position: relative;
        }

        .speak-btn-modal {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.3s;
        }

        .speak-btn-modal:hover {
            background: #667eea;
            color: white;
            transform: scale(1.1);
        }

        .random-word-card.flipped .speak-btn-modal {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .random-word-card.flipped .speak-btn-modal:hover {
            background: rgba(255, 255, 255, 0.4);
        }

        .random-word-card:hover {
            transform: scale(1.02);
        }

        .random-word-card .dutch-word {
            font-size: 3em;
            font-weight: bold;
            margin-bottom: 30px;
            color: #667eea;
        }

        .random-word-card .english-meaning {
            font-size: 1.8em;
            display: none;
            color: #555;
        }

        .random-word-card.flipped {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: #764ba2;
        }

        .random-word-card.flipped .dutch-word {
            color: white;
        }

        .random-word-card.flipped .english-meaning {
            display: block;
            color: white;
            animation: fadeIn 0.3s ease;
        }

        .random-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .random-btn {
            padding: 15px 40px;
            font-size: 1.1em;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .random-btn.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .random-btn.secondary {
            background: #f0f0f0;
            color: #333;
        }

        .random-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸ‡³ğŸ‡± è·å…°è¯­A2è¯æ±‡å­¦ä¹ ç³»ç»Ÿ</h1>
            <div class="subtitle">LINK+ 0â†’A2 å®Œæ•´è¯æ±‡è¡¨ - ç‚¹å‡»å¡ç‰‡æŸ¥çœ‹è‹±æ–‡é‡Šä¹‰</div>
        </header>

        <div class="controls">
            <div class="stats-bar">
                <div class="stat-item">
                    <div class="stat-number" id="totalWords">0</div>
                    <div class="stat-label">æ€»è¯æ±‡é‡</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="filteredWords">0</div>
                    <div class="stat-label">å½“å‰æ˜¾ç¤º</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="learnedWords">0</div>
                    <div class="stat-label">å·²å­¦ä¹ </div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="progress">0%</div>
                    <div class="stat-label">å­¦ä¹ è¿›åº¦</div>
                </div>
            </div>

            <div class="mode-toggle">
                <button class="mode-btn active" data-mode="cards">å¡ç‰‡æ¨¡å¼</button>
                <button class="mode-btn" data-mode="list">åˆ—è¡¨æ¨¡å¼</button>
                <button class="mode-btn" data-mode="random">éšæœºå­¦ä¹ </button>
            </div>

            <div class="search-section">
                <input type="text" class="search-box" id="searchBox" placeholder="æœç´¢è·å…°è¯­æˆ–è‹±æ–‡å•è¯...">
                <button class="filter-btn" onclick="clearSearch()">æ¸…ç©º</button>
            </div>

            <div class="filter-section">
                <span class="filter-label">æŒ‰ä¸»é¢˜ç­›é€‰ï¼š</span>
                <div class="filter-buttons" id="themeFilters">
                    <button class="filter-btn active" data-theme="all">å…¨éƒ¨ä¸»é¢˜</button>
                </div>
            </div>

            <div class="filter-section">
                <span class="filter-label">æŒ‰å­—æ¯ç­›é€‰ï¼š</span>
                <div class="filter-buttons" id="letterFilters">
                    <button class="filter-btn active" data-letter="all">å…¨éƒ¨</button>
                </div>
            </div>
        </div>

        <div class="vocabulary-container">
            <div class="cards-view active" id="cardsView"></div>
            <div class="list-view" id="listView">
                <table class="vocabulary-table">
                    <thead>
                        <tr>
                            <th>è·å…°è¯­</th>
                            <th>è‹±æ–‡</th>
                            <th>ä¸»é¢˜</th>
                        </tr>
                    </thead>
                    <tbody id="tableBody"></tbody>
                </table>
            </div>
        </div>

        <div class="action-buttons">
            <button class="action-btn" onclick="shuffleWords()" title="éšæœºæ’åº">ğŸ”€</button>
            <button class="action-btn" onclick="resetProgress()" title="é‡ç½®è¿›åº¦">ğŸ”„</button>
            <button class="action-btn" onclick="exportData()" title="å¯¼å‡ºè¿›åº¦">ğŸ’¾</button>
            <button class="action-btn" onclick="importData()" title="å¯¼å…¥è¿›åº¦">ğŸ“‚</button>
            <input type="file" id="importFile" accept=".json" style="display: none;" onchange="handleImport(event)">
        </div>
    </div>

    <!-- éšæœºå­¦ä¹ æ¨¡æ€æ¡† -->
    <div id="randomModal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close" id="modalCloseBtn">Ã—</button>
            <div id="randomCardContainer"></div>
        </div>
    </div>

    <!-- è¯¦ç»†ä¿¡æ¯æ¨¡æ€æ¡† -->
    <div id="detailModal" class="modal-overlay" onclick="handleDetailModalClick(event)">
        <div class="modal-content detail-modal">
            <button class="modal-close" onclick="closeDetailModal()">Ã—</button>
            <div id="detailContent"></div>
        </div>
    </div>

    <!-- é€‰è¯ç¿»è¯‘å¼¹å‡ºæ¡† -->
    <div id="translationPopup" class="translation-popup">
        <div class="translation-content">
            <div class="translation-word"></div>
            <div class="translation-meaning"></div>
            <button class="translation-speak" onclick="speakSelection()">ğŸ”Š</button>
        </div>
    </div>

    <script src="vocabulary-data.js"></script>
    <script>
        // vocabulary is loaded from vocabulary-data.js

        let learnedWords = new Set();
        let currentFilter = 'all';
        let currentLetter = 'all';
        let currentMode = 'cards';

        // é˜²æŠ–å‡½æ•°
        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), delay);
            };
        }

        // é”®ç›˜å¯¼èˆªç®¡ç†å™¨
        const KeyboardNavigation = {
            currentIndex: -1,
            cards: [],

            init() {
                document.addEventListener('keydown', (e) => this.handleKeyPress(e));
            },

            updateCards() {
                // è·å–å½“å‰æ˜¾ç¤ºçš„æ‰€æœ‰å¡ç‰‡
                if (currentMode === 'cards') {
                    this.cards = Array.from(document.querySelectorAll('#cardsView .word-card'));
                } else {
                    this.cards = [];
                }
            },

            handleKeyPress(e) {
                // å¦‚æœæ­£åœ¨è¾“å…¥ï¼Œä¸å¤„ç†å¿«æ·é”®
                if (document.activeElement.tagName === 'INPUT') return;

                // åªåœ¨å¡ç‰‡æ¨¡å¼ä¸‹å¯ç”¨å¯¼èˆª
                if (currentMode !== 'cards' || this.cards.length === 0) {
                    // ä½†æ˜¯åœ¨éšæœºæ¨¡å¼ä¸‹ä¹Ÿå¤„ç†ç©ºæ ¼å’Œæ–¹å‘é”®
                    if (currentMode === 'random' && document.getElementById('randomModal').classList.contains('active')) {
                        if (e.key === ' ' || e.key === 'Enter') {
                            e.preventDefault();
                            const card = document.getElementById('currentRandomCard');
                            if (card) card.classList.toggle('flipped');
                        } else if (e.key === 'ArrowRight' || e.key === 'ArrowLeft') {
                            e.preventDefault();
                            showRandomWord();
                        }
                    }
                    return;
                }

                switch(e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        this.navigate(-1);
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        this.navigate(1);
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        this.navigateRow(-1);
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        this.navigateRow(1);
                        break;
                    case ' ':
                    case 'Enter':
                        e.preventDefault();
                        this.toggleCurrentCard();
                        break;
                    case 's':
                    case 'S':
                        e.preventDefault();
                        this.speakCurrentCard();
                        break;
                }
            },

            navigate(direction) {
                if (this.cards.length === 0) return;

                this.currentIndex += direction;
                if (this.currentIndex < 0) this.currentIndex = this.cards.length - 1;
                if (this.currentIndex >= this.cards.length) this.currentIndex = 0;

                this.focusCard();
            },

            navigateRow(direction) {
                if (this.cards.length === 0) return;

                // è®¡ç®—æ¯è¡Œçš„å¡ç‰‡æ•°
                const container = document.getElementById('cardsView');
                const containerWidth = container.offsetWidth;
                const cardWidth = this.cards[0].offsetWidth + 15; // åŒ…æ‹¬gap
                const cardsPerRow = Math.floor(containerWidth / cardWidth);

                this.currentIndex += cardsPerRow * direction;
                this.currentIndex = Math.max(0, Math.min(this.cards.length - 1, this.currentIndex));

                this.focusCard();
            },

            focusCard() {
                // ç§»é™¤ä¹‹å‰çš„ç„¦ç‚¹
                this.cards.forEach(card => card.style.outline = 'none');

                if (this.currentIndex >= 0 && this.currentIndex < this.cards.length) {
                    const card = this.cards[this.currentIndex];
                    card.style.outline = '3px solid #667eea';
                    card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            },

            toggleCurrentCard() {
                if (this.currentIndex >= 0 && this.currentIndex < this.cards.length) {
                    const card = this.cards[this.currentIndex];
                    card.click();
                }
            },

            speakCurrentCard() {
                if (this.currentIndex >= 0 && this.currentIndex < this.cards.length) {
                    const card = this.cards[this.currentIndex];
                    const speakBtn = card.querySelector('.speak-btn');
                    if (speakBtn) speakBtn.click();
                }
            }
        };

        // å‘éŸ³ç®¡ç†å™¨
        const SpeechManager = {
            synth: window.speechSynthesis,
            voices: [],
            dutchVoice: null,

            init() {
                // åŠ è½½è¯­éŸ³åˆ—è¡¨
                this.loadVoices();

                // æŸäº›æµè§ˆå™¨éœ€è¦ç­‰å¾…voicesåŠ è½½
                if (this.synth.onvoiceschanged !== undefined) {
                    this.synth.onvoiceschanged = () => this.loadVoices();
                }
            },

            loadVoices() {
                this.voices = this.synth.getVoices();

                // æŸ¥æ‰¾è·å…°è¯­è¯­éŸ³
                this.dutchVoice = this.voices.find(voice =>
                    voice.lang.includes('nl') || voice.lang.includes('NL')
                );

                // å¦‚æœæ²¡æœ‰è·å…°è¯­ï¼Œå°è¯•ä½¿ç”¨é»˜è®¤è¯­éŸ³
                if (!this.dutchVoice && this.voices.length > 0) {
                    this.dutchVoice = this.voices[0];
                }
            },

            speak(text) {
                // åœæ­¢ä¹‹å‰çš„å‘éŸ³
                this.synth.cancel();

                const utterance = new SpeechSynthesisUtterance(text);

                // è®¾ç½®è·å…°è¯­
                utterance.lang = 'nl-NL';

                // å¦‚æœæœ‰è·å…°è¯­è¯­éŸ³ï¼Œä½¿ç”¨å®ƒ
                if (this.dutchVoice) {
                    utterance.voice = this.dutchVoice;
                }

                // è°ƒæ•´è¯­é€Ÿå’ŒéŸ³è°ƒ
                utterance.rate = 0.9;
                utterance.pitch = 1.0;
                utterance.volume = 1.0;

                // å‘éŸ³
                this.synth.speak(utterance);
            },

            isSupported() {
                return 'speechSynthesis' in window;
            }
        };

        // è™šæ‹Ÿæ»šåŠ¨ç®¡ç†å™¨
        const VirtualScroller = {
            BATCH_SIZE: 50, // æ¯æ‰¹åŠ è½½50ä¸ªå¡ç‰‡
            observer: null,
            loadedCount: 0,
            currentWords: [],
            container: null,

            init(words) {
                this.currentWords = words;
                this.loadedCount = 0;
                this.container = document.getElementById('cardsView');

                // åˆ›å»ºIntersection Observer
                this.observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            this.loadMore();
                        }
                    });
                }, {
                    root: null,
                    rootMargin: '100px',
                    threshold: 0.1
                });

                // åˆå§‹åŠ è½½
                this.loadBatch();
            },

            loadBatch() {
                const start = this.loadedCount;
                const end = Math.min(start + this.BATCH_SIZE, this.currentWords.length);

                for (let i = start; i < end; i++) {
                    const card = createWordCard(this.currentWords[i]);
                    this.container.appendChild(card);
                }

                this.loadedCount = end;

                // æ·»åŠ åŠ è½½è§¦å‘å™¨
                if (this.loadedCount < this.currentWords.length) {
                    this.addLoadTrigger();
                }
            },

            loadMore() {
                if (this.loadedCount < this.currentWords.length) {
                    this.removeTrigger();
                    this.loadBatch();
                }
            },

            addLoadTrigger() {
                const trigger = document.createElement('div');
                trigger.className = 'virtual-scroll-trigger';
                trigger.style.height = '1px';
                trigger.style.visibility = 'hidden';
                this.container.appendChild(trigger);
                this.observer.observe(trigger);
            },

            removeTrigger() {
                const trigger = this.container.querySelector('.virtual-scroll-trigger');
                if (trigger) {
                    this.observer.unobserve(trigger);
                    trigger.remove();
                }
            },

            destroy() {
                if (this.observer) {
                    this.observer.disconnect();
                }
                this.loadedCount = 0;
                this.currentWords = [];
            }
        };

        // LocalStorageç®¡ç†
        const StorageManager = {
            KEYS: {
                LEARNED_WORDS: 'dutchA2_learnedWords',
                FILTER_THEME: 'dutchA2_filterTheme',
                FILTER_LETTER: 'dutchA2_filterLetter',
                VIEW_MODE: 'dutchA2_viewMode'
            },

            saveLearnedWords() {
                try {
                    localStorage.setItem(this.KEYS.LEARNED_WORDS, JSON.stringify([...learnedWords]));
                } catch(e) {
                    console.error('Failed to save learned words:', e);
                }
            },

            loadLearnedWords() {
                try {
                    const saved = localStorage.getItem(this.KEYS.LEARNED_WORDS);
                    if (saved) {
                        learnedWords = new Set(JSON.parse(saved));
                    }
                } catch(e) {
                    console.error('Failed to load learned words:', e);
                }
            },

            savePreferences() {
                try {
                    localStorage.setItem(this.KEYS.FILTER_THEME, currentFilter);
                    localStorage.setItem(this.KEYS.FILTER_LETTER, currentLetter);
                    localStorage.setItem(this.KEYS.VIEW_MODE, currentMode);
                } catch(e) {
                    console.error('Failed to save preferences:', e);
                }
            },

            loadPreferences() {
                try {
                    const savedTheme = localStorage.getItem(this.KEYS.FILTER_THEME);
                    const savedLetter = localStorage.getItem(this.KEYS.FILTER_LETTER);
                    const savedMode = localStorage.getItem(this.KEYS.VIEW_MODE);

                    if (savedTheme) currentFilter = savedTheme;
                    if (savedLetter) currentLetter = savedLetter;
                    if (savedMode) currentMode = savedMode;
                } catch(e) {
                    console.error('Failed to load preferences:', e);
                }
            }
        };

        // åˆå§‹åŒ–
        function init() {
            // å…ˆåŠ è½½ä¿å­˜çš„æ•°æ®
            StorageManager.loadLearnedWords();
            StorageManager.loadPreferences();

            // åˆå§‹åŒ–å‘éŸ³åŠŸèƒ½
            SpeechManager.init();

            // åˆå§‹åŒ–é”®ç›˜å¯¼èˆª
            KeyboardNavigation.init();

            // åˆå§‹åŒ–é€‰è¯ç¿»è¯‘åŠŸèƒ½
            SelectionTranslator.init();

            extractThemes();
            extractLetters();

            // æ¢å¤ä¿å­˜çš„ç­›é€‰çŠ¶æ€
            restoreFilterStates();

            displayVocabulary();
            updateStats();
            setupEventListeners();
        }

        // æ¢å¤ç­›é€‰çŠ¶æ€
        function restoreFilterStates() {
            // æ¢å¤ä¸»é¢˜ç­›é€‰
            if (currentFilter !== 'all') {
                document.querySelectorAll('#themeFilters .filter-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.theme === currentFilter) {
                        btn.classList.add('active');
                    }
                });
            }

            // æ¢å¤å­—æ¯ç­›é€‰
            if (currentLetter !== 'all') {
                document.querySelectorAll('#letterFilters .filter-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.letter === currentLetter) {
                        btn.classList.add('active');
                    }
                });
            }

            // æ¢å¤è§†å›¾æ¨¡å¼
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.mode === currentMode) {
                    btn.classList.add('active');
                }
            });

            document.getElementById('cardsView').style.display = currentMode === 'list' ? 'none' : 'grid';
            document.getElementById('listView').style.display = currentMode === 'list' ? 'block' : 'none';
        }

        // æå–ä¸»é¢˜
        function extractThemes() {
            const themes = [...new Set(vocabulary.map(word => word.theme))].sort((a, b) => a - b);
            const themeNames = {
                1: "åŸºç¡€", 2: "é£Ÿç‰©", 3: "æ—¥å¸¸", 4: "é¥®é£Ÿ", 5: "ä½æˆ¿",
                6: "äº¤é€š", 7: "å¥åº·", 8: "æ´»åŠ¨", 9: "è´­ç‰©", 10: "å®‰å…¨",
                11: "æ—¶é—´", 12: "æ•™è‚²", 13: "å®¶å±…", 14: "å…³ç³»", 15: "å¤–è¡¨",
                16: "è¡Œæ”¿", 17: "å·¥ä½œ", 18: "è‡ªç„¶", 19: "ç»æµ", 20: "ç¤¾ä¼š"
            };

            const filtersDiv = document.getElementById('themeFilters');
            themes.forEach(theme => {
                const btn = document.createElement('button');
                btn.className = 'filter-btn';
                btn.dataset.theme = theme;
                btn.textContent = `ä¸»é¢˜ ${theme} - ${themeNames[theme] || 'å…¶ä»–'}`;
                btn.onclick = () => filterByTheme(theme);
                filtersDiv.appendChild(btn);
            });
        }

        // æå–å­—æ¯
        function extractLetters() {
            const letters = [...new Set(vocabulary.map(word => word.dutch[0].toUpperCase()))].sort();
            const filtersDiv = document.getElementById('letterFilters');

            letters.forEach(letter => {
                const btn = document.createElement('button');
                btn.className = 'filter-btn';
                btn.dataset.letter = letter;
                btn.textContent = letter;
                btn.onclick = () => filterByLetter(letter);
                filtersDiv.appendChild(btn);
            });
        }

        // æ˜¾ç¤ºè¯æ±‡
        function displayVocabulary() {
            let filtered = vocabulary;

            // åº”ç”¨ä¸»é¢˜ç­›é€‰
            if (currentFilter !== 'all') {
                filtered = filtered.filter(word => word.theme == currentFilter);
            }

            // åº”ç”¨å­—æ¯ç­›é€‰
            if (currentLetter !== 'all') {
                filtered = filtered.filter(word => word.dutch[0].toUpperCase() === currentLetter);
            }

            // åº”ç”¨æœç´¢ç­›é€‰
            const searchTerm = document.getElementById('searchBox').value.toLowerCase();
            if (searchTerm) {
                filtered = filtered.filter(word =>
                    word.dutch.toLowerCase().includes(searchTerm) ||
                    word.english.toLowerCase().includes(searchTerm)
                );
            }

            if (currentMode === 'cards') {
                displayCards(filtered);
            } else if (currentMode === 'list') {
                displayList(filtered);
            } else if (currentMode === 'random') {
                displayRandom(filtered);
            }

            document.getElementById('filteredWords').textContent = filtered.length;

            // æ›´æ–°é”®ç›˜å¯¼èˆªçš„å¡ç‰‡åˆ—è¡¨
            setTimeout(() => KeyboardNavigation.updateCards(), 100);
        }

        // æ˜¾ç¤ºå¡ç‰‡
        function displayCards(words) {
            const container = document.getElementById('cardsView');
            container.innerHTML = '';

            // æ¸…ç†ä¹‹å‰çš„è™šæ‹Ÿæ»šåŠ¨å™¨
            VirtualScroller.destroy();

            // å¦‚æœå•è¯æ•°é‡è¾ƒå°‘ï¼Œç›´æ¥æ¸²æŸ“
            if (words.length <= 100) {
                words.forEach(word => {
                    const card = createWordCard(word);
                    container.appendChild(card);
                });
            } else {
                // ä½¿ç”¨è™šæ‹Ÿæ»šåŠ¨
                VirtualScroller.init(words);
            }
        }

        // åˆ›å»ºå•è¯å¡ç‰‡
        function createWordCard(word) {
            const card = document.createElement('div');
            card.className = 'word-card';
            if (learnedWords.has(word.dutch)) {
                card.classList.add('learned');
            }

            card.innerHTML = `
                ${SpeechManager.isSupported() ? '<button class="speak-btn" title="å‘éŸ³">ğŸ”Š</button>' : ''}
                <button class="more-btn" title="æ›´å¤šä¿¡æ¯">â‹¯</button>
                <div class="theme-tag">ä¸»é¢˜ ${word.theme}</div>
                <div class="dutch-word">${word.dutch}</div>
                <div class="english-meaning">${word.english}</div>
            `;

            // å‘éŸ³æŒ‰é’®äº‹ä»¶
            const speakBtn = card.querySelector('.speak-btn');
            if (speakBtn) {
                speakBtn.onclick = function(e) {
                    e.stopPropagation();
                    SpeechManager.speak(word.dutch);
                };
            }

            // æ›´å¤šæŒ‰é’®äº‹ä»¶
            const moreBtn = card.querySelector('.more-btn');
            if (moreBtn) {
                moreBtn.onclick = function(e) {
                    e.stopPropagation();
                    showDetailModal(word);
                };
            }

            card.onclick = function(e) {
                // å¦‚æœç‚¹å‡»çš„æ˜¯å‘éŸ³æŒ‰é’®æˆ–æ›´å¤šæŒ‰é’®ï¼Œä¸ç¿»è½¬å¡ç‰‡
                if (e.target.classList.contains('speak-btn') || e.target.classList.contains('more-btn')) return;

                this.classList.toggle('flipped');
                if (this.classList.contains('flipped')) {
                    learnedWords.add(word.dutch);
                    this.classList.add('learned');
                    updateStats();
                    StorageManager.saveLearnedWords();
                }
            };

            return card;
        }

        // æ˜¾ç¤ºåˆ—è¡¨
        function displayList(words) {
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = '';

            words.forEach(word => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td><strong>${word.dutch}</strong></td>
                    <td>${word.english}</td>
                    <td><span class="theme-badge">ä¸»é¢˜ ${word.theme}</span></td>
                `;
                tbody.appendChild(row);
            });
        }
        
        // ä»å¤šä¸ªè¯å…¸æºè·å–è¯æ±‡æ•°æ®
        async function fetchWiktionaryData(word) {
            const result = {
                hasOnlineData: false,
                wordType: '',
                conjugations: [],
                examples: [],
                etymology: '',
                relatedWords: [],
                definitions: []
            };

            // ç­–ç•¥1: ä»Tatoebaè·å–çœŸå®ä¾‹å¥
            try {
                const tatoebaUrl = `https://tatoeba.org/en/api_v0/search?from=nld&query=${encodeURIComponent(word.dutch)}&to=eng`;
                const proxyUrl = 'https://api.allorigins.win/raw?url=';

                const tatoebaResponse = await fetch(proxyUrl + encodeURIComponent(tatoebaUrl));
                if (tatoebaResponse.ok) {
                    const tatoebaData = await tatoebaResponse.json();

                    if (tatoebaData && tatoebaData.results) {
                        // æå–å‰5ä¸ªä¾‹å¥
                        const sentences = tatoebaData.results.slice(0, 5);
                        for (const sentence of sentences) {
                            if (sentence.text && sentence.text.toLowerCase().includes(word.dutch.toLowerCase())) {
                                // æŸ¥æ‰¾ç¿»è¯‘
                                let translation = '';
                                if (sentence.translations) {
                                    for (const trans of sentence.translations) {
                                        if (trans.lang === 'eng') {
                                            translation = trans.text;
                                            break;
                                        }
                                    }
                                }

                                result.examples.push({
                                    dutch: sentence.text,
                                    english: translation || '(Translation not available)'
                                });
                                result.hasOnlineData = true;
                            }
                        }
                    }
                }
            } catch (err) {
                console.log('Tatoeba fetch failed:', err);
            }

            // ç­–ç•¥2: ä»Glosbeè¯å…¸è·å–æ•°æ®
            try {
                const glosbeUrl = `https://api.glosbe.com/api/translate/nl/en/${encodeURIComponent(word.dutch)}`;
                const proxyUrl = 'https://api.allorigins.win/raw?url=';

                const glosbeResponse = await fetch(proxyUrl + encodeURIComponent(glosbeUrl));
                if (glosbeResponse.ok) {
                    const glosbeData = await glosbeResponse.json();

                    if (glosbeData && glosbeData.examples) {
                        // è·å–ä¾‹å¥
                        for (const example of glosbeData.examples.slice(0, 3)) {
                            if (example.first && example.second) {
                                result.examples.push({
                                    dutch: example.first,
                                    english: example.second
                                });
                                result.hasOnlineData = true;
                            }
                        }
                    }

                    // è·å–å®šä¹‰
                    if (glosbeData && glosbeData.tuc) {
                        for (const tuc of glosbeData.tuc.slice(0, 3)) {
                            if (tuc.meanings) {
                                for (const meaning of tuc.meanings) {
                                    if (meaning.text) {
                                        result.definitions.push(meaning.text);
                                    }
                                }
                            }
                        }
                    }
                }
            } catch (err) {
                console.log('Glosbe fetch failed:', err);
            }

            // ç­–ç•¥3: ä»Lingueeè·å–ä¾‹å¥ï¼ˆé€šè¿‡ç½‘é¡µæŠ“å–ï¼‰
            try {
                const lingueeUrl = `https://www.linguee.com/dutch-english/search?source=dutch&query=${encodeURIComponent(word.dutch)}`;
                const proxyUrl = 'https://api.allorigins.win/raw?url=';

                const lingueeResponse = await fetch(proxyUrl + encodeURIComponent(lingueeUrl));
                if (lingueeResponse.ok) {
                    const html = await lingueeResponse.text();

                    // ç®€å•çš„HTMLè§£ææ¥è·å–ä¾‹å¥
                    const exampleRegex = /<span class='tag_s'>([^<]+)<\/span>.*?<span class='tag_t'>([^<]+)<\/span>/g;
                    let match;
                    let count = 0;

                    while ((match = exampleRegex.exec(html)) !== null && count < 3) {
                        if (match[1].toLowerCase().includes(word.dutch.toLowerCase())) {
                            result.examples.push({
                                dutch: match[1].trim(),
                                english: match[2].trim()
                            });
                            result.hasOnlineData = true;
                            count++;
                        }
                    }
                }
            } catch (err) {
                console.log('Linguee fetch failed:', err);
            }

            // ç­–ç•¥4: ç”Ÿæˆä¸Šä¸‹æ–‡ç›¸å…³çš„ä¾‹å¥ï¼ˆä½œä¸ºåå¤‡ï¼‰
            if (result.examples.length === 0) {
                result.examples = generateContextualExamples(word);
            }

            // å¦‚æœæ˜¯åŠ¨è¯ï¼Œç”Ÿæˆå˜ä½
            if (word.dutch.endsWith('en')) {
                result.wordType = 'verb';
                result.conjugations = generateVerbConjugations(word.dutch);
            }

            return result;
        }

        // ç”Ÿæˆä¸Šä¸‹æ–‡ç›¸å…³çš„ä¾‹å¥
        function generateContextualExamples(word) {
            const examples = [];

            // åŸºäºè¯æ±‡ç±»å‹ç”Ÿæˆæ›´çœŸå®çš„ä¾‹å¥
            const templates = {
                'leren': [
                    { dutch: 'Ik wil Nederlands leren.', english: 'I want to learn Dutch.' },
                    { dutch: 'We leren nieuwe woorden elke dag.', english: 'We learn new words every day.' },
                    { dutch: 'Hij heeft veel geleerd op school.', english: 'He has learned a lot at school.' }
                ],
                'maken': [
                    { dutch: 'Ik ga een lijst maken.', english: 'I am going to make a list.' },
                    { dutch: 'Ze maakt haar huiswerk.', english: 'She is doing her homework.' },
                    { dutch: 'We hebben een fout gemaakt.', english: 'We made a mistake.' }
                ],
                'nieuws': [
                    { dutch: 'Heb je het nieuws gezien?', english: 'Did you see the news?' },
                    { dutch: 'Er is goed nieuws vandaag.', english: 'There is good news today.' },
                    { dutch: 'Ik lees het nieuws elke ochtend.', english: 'I read the news every morning.' }
                ],
                'online': [
                    { dutch: 'We werken online vandaag.', english: 'We are working online today.' },
                    { dutch: 'Je kunt het online vinden.', english: 'You can find it online.' },
                    { dutch: 'Online leren is populair.', english: 'Online learning is popular.' }
                ],
                'woorden': [
                    { dutch: 'Deze woorden zijn moeilijk.', english: 'These words are difficult.' },
                    { dutch: 'Ik ken veel Nederlandse woorden.', english: 'I know many Dutch words.' },
                    { dutch: 'Nieuwe woorden leren is leuk.', english: 'Learning new words is fun.' }
                ]
            };

            // å¦‚æœæœ‰é¢„å®šä¹‰çš„ä¾‹å¥ï¼Œä½¿ç”¨å®ƒä»¬
            if (templates[word.dutch]) {
                return templates[word.dutch];
            }

            // å¦åˆ™ç”Ÿæˆé€šç”¨ä¾‹å¥
            const genericTemplates = [
                {
                    dutch: `Wat betekent "${word.dutch}"?`,
                    english: `What does "${word.dutch}" mean?`
                },
                {
                    dutch: `Ik gebruik het woord "${word.dutch}" vaak.`,
                    english: `I use the word "${word.dutch}" often.`
                },
                {
                    dutch: `"${word.dutch}" is een belangrijk woord.`,
                    english: `"${word.dutch}" is an important word.`
                }
            ];

            return genericTemplates;
        }

        // ç”ŸæˆåŠ¨è¯å˜ä½è¡¨æ ¼æ•°æ®
        function generateVerbConjugations(verb) {
            const stem = verb.endsWith('en') ? verb.slice(0, -2) : verb;

            // è¿”å›è¡¨æ ¼æ ¼å¼çš„æ•°æ®
            return [
                { person: 'ik', present: stem, past: `${stem}te`, perfect: `heb ge${stem}d` },
                { person: 'jij/je', present: `${stem}t`, past: `${stem}te`, perfect: `hebt ge${stem}d` },
                { person: 'hij/zij/het', present: `${stem}t`, past: `${stem}te`, perfect: `heeft ge${stem}d` },
                { person: 'wij/we', present: `${stem}en`, past: `${stem}ten`, perfect: `hebben ge${stem}d` },
                { person: 'jullie', present: `${stem}en`, past: `${stem}ten`, perfect: `hebben ge${stem}d` },
                { person: 'zij/ze', present: `${stem}en`, past: `${stem}ten`, perfect: `hebben ge${stem}d` }
            ];
        }

        // ç”Ÿæˆåè¯ä¿¡æ¯ï¼ˆå† è¯å’Œå¤æ•°ï¼‰
        function generateNounInfo(noun) {
            // ç®€å•çš„è§„åˆ™æ¥åˆ¤æ–­de/het
            // è¿™é‡Œä½¿ç”¨å¸¸è§è§„åˆ™ï¼Œå®é™…åº”è¯¥ä»è¯å…¸è·å–
            let article = 'de';
            let plural = '';

            // ä¸€äº›å¸¸è§çš„hetè¯æ±‡
            const hetWords = ['kind', 'boek', 'huis', 'meisje', 'jongetje', 'ding', 'woord', 'jaar', 'uur', 'land', 'water', 'nieuws', 'journaal', 'niveau', 'onderwerp'];

            if (hetWords.some(word => noun.includes(word))) {
                article = 'het';
            }

            // å¤æ•°å½¢å¼è§„åˆ™
            if (noun.endsWith('e')) {
                plural = noun + 'n'; // boeke -> boeken
            } else if (noun.endsWith('el') || noun.endsWith('en') || noun.endsWith('er') || noun.endsWith('em')) {
                plural = noun + 's'; // artikel -> artikels
            } else if (noun.endsWith('heid')) {
                plural = noun.replace(/heid$/, 'heden'); // mogelijkheid -> mogelijkheden
            } else if (noun.endsWith('s') || noun.endsWith('f')) {
                plural = noun.slice(0, -1) + 'zen'; // huis -> huizen (simplified)
            } else {
                plural = noun + 'en'; // é»˜è®¤åŠ en
            }

            return { article, plural };
        }

        // æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯æ¨¡æ€æ¡†
        async function showDetailModal(word) {
            const modal = document.getElementById('detailModal');
            const content = document.getElementById('detailContent');

            // å…ˆæ˜¾ç¤ºåŠ è½½çŠ¶æ€
            modal.classList.add('active');
            content.innerHTML = `
                <div style="text-align: center; padding: 50px;">
                    <div style="font-size: 2em; color: #667eea; margin-bottom: 20px;">âŒ›</div>
                    <div style="color: #666;">æ­£åœ¨è·å–è¯¦ç»†ä¿¡æ¯...</div>
                    <div style="color: #999; font-size: 0.9em; margin-top: 10px;">ä»WiktionaryæŸ¥è¯¢ä¸­...</div>
                </div>
            `;

            // å°è¯•ä»Wiktionaryè·å–æ•°æ®
            let details = await fetchWiktionaryData(word);

            // å¦‚æœæ²¡æœ‰è·å–åˆ°ï¼Œä½¿ç”¨æœ¬åœ°ç”Ÿæˆçš„æ•°æ®
            if (!details || !details.hasOnlineData) {
                details = getWordDetails(word);
            }

            // åˆå¹¶APIæ•°æ®æ ¼å¼
            let displayData = {
                pronunciation: details.pronunciation || '',
                type: details.wordType || details.type || '',
                gender: details.gender || '',
                conjugations: details.conjugations || details.conjugation || null,
                examples: details.examples || [],
                related: details.relatedWords || details.related || [],
                etymology: details.etymology || '',
                hasOnlineData: details.hasOnlineData || false,
                nounInfo: null
            };

            // å¦‚æœæ˜¯åè¯ï¼Œç”Ÿæˆåè¯ä¿¡æ¯
            if (!displayData.conjugations && (displayData.type === 'noun' || !word.dutch.endsWith('en'))) {
                // æ’é™¤æ˜æ˜¾çš„åŠ¨è¯
                const verbEndings = ['en', 'eren', 'elen', 'enen'];
                const isLikelyVerb = verbEndings.some(ending => word.dutch.endsWith(ending));

                if (!isLikelyVerb) {
                    displayData.nounInfo = generateNounInfo(word.dutch);
                }
            }

            // æ ¼å¼åŒ–ä¾‹å¥
            if (displayData.hasOnlineData && displayData.examples.length > 0) {
                // å¦‚æœä¾‹å¥æ˜¯å­—ç¬¦ä¸²æ•°ç»„ï¼Œè½¬æ¢ä¸ºå¯¹è±¡æ ¼å¼
                displayData.examples = displayData.examples.map(ex => {
                    if (typeof ex === 'string') {
                        return {
                            dutch: ex,
                            english: '(ç¿»è¯‘æš‚æ— )'
                        };
                    }
                    return ex;
                });
            }

            content.innerHTML = `
                <div class="detail-header">
                    <div class="detail-word">${word.dutch}</div>
                    ${displayData.pronunciation ? `<div class="detail-pronunciation">[${displayData.pronunciation}]</div>` : ''}
                    <div class="detail-meaning">${word.english}</div>
                    ${SpeechManager.isSupported() ? `<button class="speak-btn" onclick="SpeechManager.speak('${word.dutch.replace(/'/g, "\\'")}')" style="position: relative; top: auto; left: auto; margin-top: 10px;">ğŸ”Š å‘éŸ³</button>` : ''}
                    ${displayData.hasOnlineData ? '<div style="color: #4CAF50; font-size: 12px; margin-top: 5px;">ğŸ“š æ•°æ®æ¥æºï¼šåœ¨çº¿è¯å…¸</div>' : ''}
                </div>

                <div class="detail-section">
                    <h3>åŸºæœ¬ä¿¡æ¯</h3>
                    <div class="detail-info">
                        <span class="detail-tag">ä¸»é¢˜ ${word.theme}</span>
                        ${displayData.type ? `<span class="detail-tag">${displayData.type}</span>` : ''}
                        ${displayData.gender ? `<span class="detail-tag">${displayData.gender}</span>` : ''}
                    </div>
                </div>

                ${displayData.etymology ? `
                <div class="detail-section">
                    <h3>è¯æº</h3>
                    <div style="padding: 10px; background: #f5f5f5; border-radius: 5px;">
                        ${displayData.etymology}
                    </div>
                </div>
                ` : ''}

                ${displayData.conjugations && displayData.conjugations.length > 0 ? `
                <div class="detail-section">
                    <h3>åŠ¨è¯å˜ä½</h3>
                    <table class="conjugation-table">
                        <thead>
                            <tr>
                                <th>äººç§°</th>
                                <th>ç°åœ¨æ—¶</th>
                                <th>è¿‡å»æ—¶</th>
                                <th>ç°åœ¨å®Œæˆæ—¶</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${displayData.conjugations.map(c => `
                                <tr>
                                    <td>${c.person || c.tense || ''}</td>
                                    <td>${c.present || c.conjugation || '-'}</td>
                                    <td>${c.past || '-'}</td>
                                    <td>${c.perfect || '-'}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
                ` : ''}

                ${displayData.nounInfo ? `
                <div class="detail-section">
                    <h3>åè¯å½¢å¼</h3>
                    <table class="conjugation-table">
                        <thead>
                            <tr>
                                <th>å† è¯</th>
                                <th>å•æ•°</th>
                                <th>å¤æ•°</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>${displayData.nounInfo.article}</strong></td>
                                <td>${word.dutch}</td>
                                <td>${displayData.nounInfo.plural}</td>
                            </tr>
                        </tbody>
                    </table>
                    <div style="margin-top: 10px; color: #666; font-size: 14px;">
                        å®Œæ•´å½¢å¼: <strong>${displayData.nounInfo.article} ${word.dutch}</strong> (å•æ•°) | <strong>de ${displayData.nounInfo.plural}</strong> (å¤æ•°)
                    </div>
                </div>
                ` : ''}

                ${displayData.examples && displayData.examples.length > 0 ? `
                <div class="detail-section">
                    <h3>ä¾‹å¥</h3>
                    ${displayData.examples.map(ex => `
                        <div class="example-sentence">
                            <div class="example-dutch selectable-text">${typeof ex === 'string' ? ex : ex.dutch}</div>
                            ${typeof ex === 'object' && ex.english ?
                                `<div class="example-english selectable-text">${ex.english}</div>` :
                                ''}
                        </div>
                    `).join('')}
                </div>
                ` : ''}

                ${displayData.related && displayData.related.length > 0 ? `
                <div class="detail-section">
                    <h3>ç›¸å…³è¯æ±‡</h3>
                    <div class="detail-info">
                        ${displayData.related.map(r => `<span class="detail-tag">${r}</span>`).join('')}
                    </div>
                </div>
                ` : ''}
            `;

            modal.classList.add('active');
        }

        // å…³é—­è¯¦ç»†ä¿¡æ¯æ¨¡æ€æ¡†
        window.closeDetailModal = function() {
            const modal = document.getElementById('detailModal');
            if (modal) {
                modal.classList.remove('active');
            }
        }

        // å¤„ç†è¯¦ç»†ä¿¡æ¯æ¨¡æ€æ¡†çš„ç‚¹å‡»äº‹ä»¶
        window.handleDetailModalClick = function(event) {
            // å¦‚æœç‚¹å‡»çš„æ˜¯æ¨¡æ€æ¡†èƒŒæ™¯ï¼ˆä¸æ˜¯å†…å®¹åŒºåŸŸï¼‰ï¼Œåˆ™å…³é—­æ¨¡æ€æ¡†
            if (event.target === event.currentTarget) {
                closeDetailModal();
            }
        }

        // æ·»åŠ ESCé”®å…³é—­è¯¦ç»†ä¿¡æ¯æ¨¡æ€æ¡†
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape' || event.keyCode === 27) {
                const detailModal = document.getElementById('detailModal');
                const randomModal = document.getElementById('randomModal');

                // ä¼˜å…ˆå…³é—­è¯¦ç»†ä¿¡æ¯æ¨¡æ€æ¡†
                if (detailModal && detailModal.classList.contains('active')) {
                    closeDetailModal();
                    event.preventDefault();
                }
                // å¦‚æœè¯¦ç»†ä¿¡æ¯æ¨¡æ€æ¡†æ²¡æœ‰æ‰“å¼€ï¼Œåˆ™å…³é—­éšæœºæ¨¡æ€æ¡†
                else if (randomModal && randomModal.classList.contains('active')) {
                    closeRandomModal();
                    event.preventDefault();
                }
            }
        });

        // é€‰è¯ç¿»è¯‘åŠŸèƒ½
        const SelectionTranslator = {
            popup: null,
            selectedText: '',
            vocabularyMap: new Map(),
            translationCache: new Map(), // ç¼“å­˜ç¿»è¯‘ç»“æœ
            isLoading: false,

            init() {
                this.popup = document.getElementById('translationPopup');

                // æ„å»ºè¯æ±‡æ˜ å°„è¡¨
                vocabulary.forEach(word => {
                    this.vocabularyMap.set(word.dutch.toLowerCase(), word);
                    // ä¹Ÿæ·»åŠ ä¸€äº›å˜å½¢
                    if (word.dutch.endsWith('en')) {
                        // åŠ¨è¯çš„ä¸€äº›å¸¸è§å˜å½¢
                        const stem = word.dutch.slice(0, -2);
                        this.vocabularyMap.set(stem + 't', word); // ç¬¬äºŒ/ä¸‰äººç§°å•æ•°
                        this.vocabularyMap.set(stem + 'te', word); // è¿‡å»å¼
                        this.vocabularyMap.set(stem + 'ten', word); // è¿‡å»å¼å¤æ•°
                        this.vocabularyMap.set('ge' + stem + 'd', word); // è¿‡å»åˆ†è¯
                        this.vocabularyMap.set('ge' + stem + 't', word); // è¿‡å»åˆ†è¯
                    }
                });

                // æ·»åŠ æ–‡æœ¬é€‰æ‹©äº‹ä»¶ç›‘å¬
                document.addEventListener('mouseup', this.handleSelection.bind(this));
                document.addEventListener('touchend', this.handleSelection.bind(this));

                // ç‚¹å‡»å…¶ä»–åœ°æ–¹å…³é—­å¼¹çª—
                document.addEventListener('mousedown', (e) => {
                    if (!this.popup.contains(e.target)) {
                        this.hidePopup();
                    }
                });
            },

            // åœ¨çº¿æŸ¥è¯¢è¯æ±‡
            async queryOnline(text) {
                // å…ˆæ£€æŸ¥ç¼“å­˜
                if (this.translationCache.has(text.toLowerCase())) {
                    return this.translationCache.get(text.toLowerCase());
                }

                try {
                    // æ–¹æ³•1: ä½¿ç”¨Google Translate API (é€šè¿‡ä»£ç†)
                    const proxyUrl = 'https://api.allorigins.win/raw?url=';
                    const translateUrl = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=nl&tl=en&dt=t&q=${encodeURIComponent(text)}`;

                    const response = await fetch(proxyUrl + encodeURIComponent(translateUrl));
                    if (response.ok) {
                        const data = await response.json();
                        if (data && data[0] && data[0][0] && data[0][0][0]) {
                            const translation = data[0][0][0];
                            const result = {
                                dutch: text,
                                english: translation,
                                source: 'online'
                            };
                            // ç¼“å­˜ç»“æœ
                            this.translationCache.set(text.toLowerCase(), result);
                            return result;
                        }
                    }
                } catch (error) {
                    console.log('Google Translate failed:', error);
                }

                // æ–¹æ³•2: ä½¿ç”¨MyMemoryç¿»è¯‘APIï¼ˆå…è´¹ï¼Œæ— éœ€APIå¯†é’¥ï¼‰
                try {
                    const myMemoryUrl = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=nl|en`;

                    const response = await fetch(myMemoryUrl);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.responseData && data.responseData.translatedText) {
                            const result = {
                                dutch: text,
                                english: data.responseData.translatedText,
                                source: 'online'
                            };
                            // ç¼“å­˜ç»“æœ
                            this.translationCache.set(text.toLowerCase(), result);
                            return result;
                        }
                    }
                } catch (error) {
                    console.log('MyMemory failed:', error);
                }

                // æ–¹æ³•3: ä½¿ç”¨LibreTranslateï¼ˆå¼€æºç¿»è¯‘APIï¼‰
                try {
                    const libreUrl = 'https://libretranslate.de/translate';
                    const response = await fetch(libreUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            q: text,
                            source: 'nl',
                            target: 'en',
                            format: 'text'
                        })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        if (data.translatedText) {
                            const result = {
                                dutch: text,
                                english: data.translatedText,
                                source: 'online'
                            };
                            this.translationCache.set(text.toLowerCase(), result);
                            return result;
                        }
                    }
                } catch (error) {
                    console.log('LibreTranslate failed:', error);
                }

                return null;
            },

            async handleSelection(e) {
                const selection = window.getSelection();
                const text = selection.toString().trim();

                if (!text || text.length > 100 || this.isLoading) {  // å…è®¸æ›´é•¿çš„æ–‡æœ¬
                    return;
                }

                // æŸ¥æ‰¾åŒ¹é…çš„è¯æ±‡
                const lowerText = text.toLowerCase();

                // 1. é¦–å…ˆå°è¯•æœ¬åœ°è¯æ±‡è¡¨ç²¾ç¡®åŒ¹é…
                const exactMatch = this.vocabularyMap.get(lowerText);
                if (exactMatch) {
                    this.selectedText = text;
                    this.showPopup(exactMatch, e);
                    return;
                }

                // 2. å¦‚æœé€‰ä¸­å¤šä¸ªè¯ï¼Œå°è¯•åŒ¹é…æ¯ä¸ªè¯
                const words = lowerText.split(/\s+/);
                if (words.length > 1 && words.length <= 3) {
                    for (const word of words) {
                        const match = this.vocabularyMap.get(word);
                        if (match) {
                            this.selectedText = word;
                            this.showPopup(match, e);
                            return;
                        }
                    }
                }

                // 3. å°è¯•å»é™¤å¸¸è§çš„åç¼€è¿›è¡ŒåŒ¹é…ï¼ˆæ›´ç²¾ç¡®çš„å˜å½¢è§„åˆ™ï¼‰
                if (words.length === 1) {
                    const possibleForms = this.getPossibleBaseForms(lowerText);
                    for (const form of possibleForms) {
                        const match = this.vocabularyMap.get(form);
                        if (match) {
                            this.selectedText = text;
                            this.showPopup(match, e);
                            return;
                        }
                    }
                }

                // 4. å¦‚æœæœ¬åœ°æ²¡æ‰¾åˆ°ï¼Œè¿›è¡Œåœ¨çº¿æŸ¥è¯¢
                this.isLoading = true;
                this.showLoadingPopup(text, e);

                const onlineResult = await this.queryOnline(text);
                this.isLoading = false;

                if (onlineResult) {
                    this.selectedText = text;
                    this.showPopup(onlineResult, e);
                } else {
                    // 5. å¦‚æœåœ¨çº¿æŸ¥è¯¢ä¹Ÿå¤±è´¥ï¼Œå°è¯•æœ¬åœ°éƒ¨åˆ†åŒ¹é…ä½œä¸ºæœ€åæ‰‹æ®µ
                    for (const [key, value] of this.vocabularyMap.entries()) {
                        const regex = new RegExp(`\\b${key}\\b`, 'i');
                        if (regex.test(lowerText)) {
                            this.selectedText = text;
                            this.showPopup(value, e);
                            return;
                        }
                    }

                    // æ˜¾ç¤ºæœªæ‰¾åˆ°
                    this.showNotFound(text, e);
                }
            },

            showLoadingPopup(text, event) {
                const popup = this.popup;
                const wordEl = popup.querySelector('.translation-word');
                const meaningEl = popup.querySelector('.translation-meaning');

                wordEl.textContent = text;
                meaningEl.innerHTML = '<span style="color: #999;">æ­£åœ¨æŸ¥è¯¢...</span>';

                this.positionPopup(event);
                popup.classList.add('active');
            },

            showNotFound(text, event) {
                const popup = this.popup;
                const wordEl = popup.querySelector('.translation-word');
                const meaningEl = popup.querySelector('.translation-meaning');

                wordEl.textContent = text;
                meaningEl.innerHTML = '<span style="color: #999;">æœªæ‰¾åˆ°ç¿»è¯‘</span>';

                this.positionPopup(event);
                popup.classList.add('active');
            },

            getPossibleBaseForms(word) {
                const forms = [];

                // åŠ¨è¯å˜å½¢è§„åˆ™
                if (word.endsWith('t')) {
                    forms.push(word.slice(0, -1) + 'en');  // speelt -> spelen
                }
                if (word.endsWith('te')) {
                    forms.push(word.slice(0, -2) + 'en');  // speelde -> spelen
                }
                if (word.endsWith('ten')) {
                    forms.push(word.slice(0, -3) + 'en');  // speelden -> spelen
                }
                if (word.startsWith('ge') && word.endsWith('d')) {
                    forms.push(word.slice(2, -1) + 'en');  // gespeeld -> spelen
                }
                if (word.startsWith('ge') && word.endsWith('t')) {
                    forms.push(word.slice(2, -1) + 'en');  // gemaakt -> maken
                }

                // åè¯å¤æ•°è§„åˆ™
                if (word.endsWith('en') && word.length > 3) {
                    forms.push(word.slice(0, -2));  // woorden -> woord
                    forms.push(word.slice(0, -1));  // boeken -> boek
                }
                if (word.endsWith('s')) {
                    forms.push(word.slice(0, -1));  // artikels -> artikel
                }

                // å½¢å®¹è¯å˜åŒ–
                if (word.endsWith('e')) {
                    forms.push(word.slice(0, -1));  // goede -> goed
                }

                return forms;
            },

            showPopup(word, event) {
                const popup = this.popup;
                const wordEl = popup.querySelector('.translation-word');
                const meaningEl = popup.querySelector('.translation-meaning');

                wordEl.textContent = word.dutch;

                // æ ¹æ®æ¥æºæ˜¾ç¤ºä¸åŒçš„ç¿»è¯‘
                if (word.source === 'online') {
                    meaningEl.innerHTML = `${word.english} <span style="color: #4CAF50; font-size: 12px;">ğŸ“¡</span>`;
                } else {
                    meaningEl.textContent = word.english;
                }

                this.positionPopup(event);
                popup.classList.add('active');

                // ä¿å­˜å½“å‰è¯æ±‡ä¾›å‘éŸ³ä½¿ç”¨
                popup.dataset.currentWord = word.dutch;
            },

            positionPopup(event) {
                const popup = this.popup;

                // è®¡ç®—ä½ç½®
                let rect;
                try {
                    rect = window.getSelection().getRangeAt(0).getBoundingClientRect();
                } catch (e) {
                    // å¦‚æœæ²¡æœ‰selectionï¼Œä½¿ç”¨é¼ æ ‡ä½ç½®
                    rect = {
                        left: event.clientX,
                        top: event.clientY,
                        right: event.clientX,
                        bottom: event.clientY,
                        width: 0
                    };
                }

                let left = rect.left + rect.width / 2;
                let top = rect.top - 10;

                // ç¡®ä¿å¼¹çª—ä¸ä¼šè¶…å‡ºè§†å£
                popup.style.display = 'block';
                const popupRect = popup.getBoundingClientRect();

                left = Math.min(left, window.innerWidth - popupRect.width - 10);
                left = Math.max(left, 10);

                if (top - popupRect.height < 10) {
                    top = rect.bottom + 10; // æ˜¾ç¤ºåœ¨é€‰ä¸­æ–‡æœ¬ä¸‹æ–¹
                } else {
                    top = top - popupRect.height; // æ˜¾ç¤ºåœ¨é€‰ä¸­æ–‡æœ¬ä¸Šæ–¹
                }

                popup.style.left = left + 'px';
                popup.style.top = top + 'px';
            },

            hidePopup() {
                this.popup.classList.remove('active');
                this.popup.style.display = 'none';
            }
        };

        // å‘éŸ³é€‰ä¸­çš„è¯æ±‡
        window.speakSelection = function() {
            const popup = document.getElementById('translationPopup');
            const word = popup.dataset.currentWord;
            if (word && SpeechManager.isSupported()) {
                SpeechManager.speak(word);
            }
        }

        // è·å–å•è¯è¯¦ç»†ä¿¡æ¯
        function getWordDetails(word) {
            // åŸºç¡€ä¿¡æ¯
            const details = {
                pronunciation: null,
                type: null,
                gender: null,
                conjugation: null,
                examples: [],
                related: []
            };

            // æ›´å¥½çš„ä¾‹å¥ç”Ÿæˆç³»ç»Ÿ
            const exampleDatabase = {
                // åŠ¨è¯ä¾‹å¥æ¨¡æ¿
                verbs: {
                    'eten': [
                        { dutch: 'Ik eet een appel voor het ontbijt.', english: 'I eat an apple for breakfast.' },
                        { dutch: 'We eten vanavond bij mijn ouders.', english: 'We are eating at my parents\' tonight.' },
                        { dutch: 'Heb je al gegeten?', english: 'Have you eaten yet?' }
                    ],
                    'drinken': [
                        { dutch: 'Ik drink graag koffie in de ochtend.', english: 'I like to drink coffee in the morning.' },
                        { dutch: 'Wat wil je drinken?', english: 'What would you like to drink?' },
                        { dutch: 'Hij drinkt nooit alcohol.', english: 'He never drinks alcohol.' }
                    ],
                    'lopen': [
                        { dutch: 'Ik loop elke dag naar het werk.', english: 'I walk to work every day.' },
                        { dutch: 'De kinderen lopen in het park.', english: 'The children are walking in the park.' },
                        { dutch: 'Hoe lang moet je lopen?', english: 'How long do you have to walk?' }
                    ],
                    'werken': [
                        { dutch: 'Ik werk vijf dagen per week.', english: 'I work five days a week.' },
                        { dutch: 'Waar werk je?', english: 'Where do you work?' },
                        { dutch: 'Ze werkt als lerares.', english: 'She works as a teacher.' }
                    ],
                    'wonen': [
                        { dutch: 'Ik woon in Amsterdam.', english: 'I live in Amsterdam.' },
                        { dutch: 'Waar woon je?', english: 'Where do you live?' },
                        { dutch: 'Hij woont hier al tien jaar.', english: 'He has lived here for ten years.' }
                    ],
                    'kopen': [
                        { dutch: 'Ik moet melk kopen.', english: 'I need to buy milk.' },
                        { dutch: 'Waar heb je dat gekocht?', english: 'Where did you buy that?' },
                        { dutch: 'Ze koopt altijd biologische producten.', english: 'She always buys organic products.' }
                    ],
                    'maken': [
                        { dutch: 'Ik maak het huiswerk nu.', english: 'I\'m doing the homework now.' },
                        { dutch: 'Kan je koffie voor me maken?', english: 'Can you make coffee for me?' },
                        { dutch: 'We maken een taart voor haar verjaardag.', english: 'We\'re making a cake for her birthday.' }
                    ],
                    'gaan': [
                        { dutch: 'Ik ga naar de winkel.', english: 'I\'m going to the shop.' },
                        { dutch: 'We gaan morgen op vakantie.', english: 'We\'re going on vacation tomorrow.' },
                        { dutch: 'Ga je mee?', english: 'Are you coming along?' }
                    ],
                    'komen': [
                        { dutch: 'Ik kom uit Nederland.', english: 'I come from the Netherlands.' },
                        { dutch: 'Wanneer kom je thuis?', english: 'When are you coming home?' },
                        { dutch: 'Hij komt altijd te laat.', english: 'He always comes late.' }
                    ],
                    'hebben': [
                        { dutch: 'Ik heb twee kinderen.', english: 'I have two children.' },
                        { dutch: 'Heb je tijd?', english: 'Do you have time?' },
                        { dutch: 'We hebben honger.', english: 'We are hungry.' }
                    ],
                    'zijn': [
                        { dutch: 'Ik ben student.', english: 'I am a student.' },
                        { dutch: 'Hij is mijn broer.', english: 'He is my brother.' },
                        { dutch: 'We zijn thuis.', english: 'We are at home.' }
                    ],
                    'zeggen': [
                        { dutch: 'Wat zeg je?', english: 'What did you say?' },
                        { dutch: 'Hij zegt altijd de waarheid.', english: 'He always tells the truth.' },
                        { dutch: 'Ik zeg het nog een keer.', english: 'I\'ll say it again.' }
                    ],
                    'vragen': [
                        { dutch: 'Mag ik je iets vragen?', english: 'May I ask you something?' },
                        { dutch: 'Hij vraagt om hulp.', english: 'He\'s asking for help.' },
                        { dutch: 'Waarom vraag je dat?', english: 'Why do you ask that?' }
                    ],
                    'beginnen': [
                        { dutch: 'De les begint om 9 uur.', english: 'The class starts at 9 o\'clock.' },
                        { dutch: 'Ik begin morgen met mijn nieuwe baan.', english: 'I start my new job tomorrow.' },
                        { dutch: 'Zullen we beginnen?', english: 'Shall we start?' }
                    ],
                    'leren': [
                        { dutch: 'Ik leer Nederlands.', english: 'I\'m learning Dutch.' },
                        { dutch: 'Ze leert snel.', english: 'She learns quickly.' },
                        { dutch: 'Wat heb je vandaag geleerd?', english: 'What did you learn today?' }
                    ],
                    'spreken': [
                        { dutch: 'Spreek je Nederlands?', english: 'Do you speak Dutch?' },
                        { dutch: 'Ik spreek een beetje Engels.', english: 'I speak a little English.' },
                        { dutch: 'We spreken morgen verder.', english: 'We\'ll continue talking tomorrow.' }
                    ],
                    'default': [
                        { dutch: 'Ik moet dat {verb}.', english: 'I need to {english}.' },
                        { dutch: 'Kan je me helpen te {verb}?', english: 'Can you help me to {english}?' },
                        { dutch: 'We gaan morgen {verb}.', english: 'We are going to {english} tomorrow.' }
                    ]
                },
                // åè¯ä¾‹å¥æ¨¡æ¿
                nouns: {
                    'default': [
                        { dutch: 'Waar is {noun}?', english: 'Where is the {english}?' },
                        { dutch: 'Ik heb een nieuw(e) {noun_clean} nodig.', english: 'I need a new {english}.' },
                        { dutch: '{noun} is erg belangrijk.', english: 'The {english} is very important.' }
                    ]
                },
                // å½¢å®¹è¯ä¾‹å¥æ¨¡æ¿
                adjectives: {
                    'default': [
                        { dutch: 'Dit is heel {adjective}.', english: 'This is very {english}.' },
                        { dutch: 'Het wordt {adjective}.', english: 'It\'s getting {english}.' },
                        { dutch: 'Dat is niet zo {adjective}.', english: 'That\'s not so {english}.' }
                    ]
                }
            };

            // æ£€æµ‹è¯æ€§å¹¶ç”Ÿæˆä¾‹å¥
            if (word.dutch.endsWith('en')) {
                details.type = 'åŠ¨è¯ (werkwoord)';

                // ç”ŸæˆåŸºæœ¬çš„åŠ¨è¯å˜ä½
                const stem = word.dutch.slice(0, -2);

                // æ›´å‡†ç¡®çš„åŠ¨è¯å˜ä½ï¼ˆå¤„ç†ç‰¹æ®Šæƒ…å†µï¼‰
                const isRegular = !['hebben', 'zijn', 'kunnen', 'mogen', 'willen', 'zullen', 'gaan', 'doen'].includes(word.dutch);

                if (isRegular) {
                    details.conjugation = [
                        { person: 'ik', present: stem, past: stem + 'te', perfect: 'heb ge' + stem + 'd/t' },
                        { person: 'jij/je', present: stem + 't', past: stem + 'te', perfect: 'hebt ge' + stem + 'd/t' },
                        { person: 'hij/zij/het', present: stem + 't', past: stem + 'te', perfect: 'heeft ge' + stem + 'd/t' },
                        { person: 'wij/we', present: word.dutch, past: stem + 'ten', perfect: 'hebben ge' + stem + 'd/t' },
                        { person: 'jullie', present: word.dutch, past: stem + 'ten', perfect: 'hebben ge' + stem + 'd/t' },
                        { person: 'zij/ze', present: word.dutch, past: stem + 'ten', perfect: 'hebben ge' + stem + 'd/t' }
                    ];
                }

                // æŸ¥æ‰¾ç‰¹å®šåŠ¨è¯çš„ä¾‹å¥ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨é»˜è®¤æ¨¡æ¿
                if (exampleDatabase.verbs[word.dutch]) {
                    details.examples = exampleDatabase.verbs[word.dutch];
                } else {
                    // ä½¿ç”¨é»˜è®¤æ¨¡æ¿
                    details.examples = exampleDatabase.verbs.default.map(ex => ({
                        dutch: ex.dutch.replace('{verb}', word.dutch).replace('{verb}', word.dutch),
                        english: ex.english.replace('{english}', word.english)
                    }));
                }

            } else if (word.dutch.startsWith('de ') || word.dutch.startsWith('het ')) {
                details.type = 'åè¯ (zelfstandig naamwoord)';
                details.gender = word.dutch.startsWith('de ') ? 'de (é€šæ€§)' : 'het (ä¸­æ€§)';

                const nounClean = word.dutch.replace(/^(de |het )/, '');

                // ä½¿ç”¨åè¯æ¨¡æ¿
                details.examples = exampleDatabase.nouns.default.map(ex => ({
                    dutch: ex.dutch
                        .replace('{noun}', word.dutch)
                        .replace('{noun_clean}', nounClean),
                    english: ex.english.replace('{english}', word.english)
                }));

            } else {
                // å…¶ä»–è¯æ€§æ£€æµ‹
                const dutchWord = word.dutch.toLowerCase();

                if (dutchWord.endsWith('lijk') || dutchWord.endsWith('ig') || dutchWord.endsWith('baar')) {
                    details.type = 'å½¢å®¹è¯ (bijvoeglijk naamwoord)';

                    details.examples = exampleDatabase.adjectives.default.map(ex => ({
                        dutch: ex.dutch.replace('{adjective}', word.dutch),
                        english: ex.english.replace('{english}', word.english)
                    }));

                } else if (dutchWord.endsWith('heid') || dutchWord.endsWith('ing') || dutchWord.endsWith('tie')) {
                    details.type = 'åè¯ (zelfstandig naamwoord)';

                    details.examples = [
                        { dutch: `De ${word.dutch} is belangrijk voor ons.`, english: `The ${word.english} is important for us.` },
                        { dutch: `Ik begrijp de ${word.dutch} niet.`, english: `I don\'t understand the ${word.english}.` }
                    ];

                } else {
                    // åŸºäºä¸»é¢˜ç”Ÿæˆæ›´ç›¸å…³çš„ä¾‹å¥
                    const themeExamples = {
                        1: [ // åŸºç¡€
                            { dutch: `${word.dutch} is een basiswoord.`, english: `${word.english} is a basic word.` },
                            { dutch: `Ik gebruik ${word.dutch} vaak.`, english: `I use ${word.english} often.` }
                        ],
                        2: [ // é£Ÿç‰©
                            { dutch: `Ik hou van ${word.dutch}.`, english: `I like ${word.english}.` },
                            { dutch: `${word.dutch} is lekker.`, english: `${word.english} is delicious.` }
                        ],
                        6: [ // äº¤é€š
                            { dutch: `Ik ga met ${word.dutch}.`, english: `I go by ${word.english}.` },
                            { dutch: `${word.dutch} is handig.`, english: `${word.english} is convenient.` }
                        ],
                        7: [ // å¥åº·
                            { dutch: `${word.dutch} is goed voor je gezondheid.`, english: `${word.english} is good for your health.` }
                        ]
                    };

                    details.type = 'å…¶ä»–';
                    details.examples = themeExamples[word.theme] || [
                        { dutch: `Dit is ${word.dutch}.`, english: `This is ${word.english}.` },
                        { dutch: `Ik heb ${word.dutch} nodig.`, english: `I need ${word.english}.` }
                    ];
                }
            }

            // æ·»åŠ ç›¸å…³è¯æ±‡ï¼ˆåŸºäºä¸»é¢˜ï¼‰
            const relatedWords = vocabulary
                .filter(w => w.theme === word.theme && w.dutch !== word.dutch)
                .slice(0, 5)
                .map(w => w.dutch);
            details.related = relatedWords;

            return details;
        }

        // å…³é—­æ¨¡æ€æ¡†ï¼ˆç¡®ä¿æ˜¯å…¨å±€å‡½æ•°ï¼‰
        window.closeRandomModal = function() {
            const modal = document.getElementById('randomModal');
            if (modal) {
                modal.classList.remove('active');
            }

            // åˆ‡æ¢å›å¡ç‰‡æ¨¡å¼ï¼Œé¿å…é‡æ–°è§¦å‘éšæœºæ¨¡å¼
            currentMode = 'cards';

            // æ›´æ–°æ¨¡å¼æŒ‰é’®çš„çŠ¶æ€
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.mode === 'cards') {
                    btn.classList.add('active');
                }
            });

            // ç¡®ä¿æ˜¾ç¤ºæ­£ç¡®çš„è§†å›¾
            document.getElementById('cardsView').style.display = 'grid';
            document.getElementById('listView').style.display = 'none';

            // ä¿å­˜åå¥½è®¾ç½®
            StorageManager.savePreferences();

            // é‡æ–°æ˜¾ç¤ºè¯æ±‡
            displayVocabulary();
        }

        // å½“å‰æ˜¾ç¤ºçš„éšæœºå•è¯é›†åˆ
        let currentRandomWords = [];

        // æ˜¾ç¤ºéšæœºå­¦ä¹ æ¨¡æ€æ¡†
        function displayRandom(words) {
            if (words.length === 0) return;

            currentRandomWords = words;
            const modal = document.getElementById('randomModal');

            // æ˜¾ç¤ºéšæœºå•è¯
            showRandomWord();

            // æ˜¾ç¤ºæ¨¡æ€æ¡†
            modal.classList.add('active');

        }

        // æ˜¾ç¤ºéšæœºå•è¯å¡ç‰‡
        function showRandomWord() {
            if (!currentRandomWords || currentRandomWords.length === 0) {
                currentRandomWords = getFilteredWords();
            }

            const randomWord = currentRandomWords[Math.floor(Math.random() * currentRandomWords.length)];
            const container = document.getElementById('randomCardContainer');

            // ä½¿ç”¨innerHTMLåˆ›å»ºå†…å®¹ï¼Œæ·»åŠ å‘éŸ³æŒ‰é’®
            container.innerHTML = `
                <button class="modal-close" id="modalCloseBtn" style="position: absolute; top: 20px; right: 20px; font-size: 30px; background: none; border: none; cursor: pointer; color: #999; z-index: 10001;">Ã—</button>
                <div class="random-word-card" id="currentRandomCard">
                    ${SpeechManager.isSupported() ? `<button class="speak-btn-modal" onclick="SpeechManager.speak('${randomWord.dutch.replace(/'/g, "\\'")}')" title="å‘éŸ³">ğŸ”Š</button>` : ''}
                    <div class="dutch-word">${randomWord.dutch}</div>
                    <div class="english-meaning">${randomWord.english}</div>
                </div>
                <div class="random-controls">
                    <button class="random-btn primary" id="nextWordBtn" onclick="showRandomWord()">
                        ä¸‹ä¸€ä¸ªå•è¯
                    </button>
                    <button class="random-btn secondary" id="closeBtn" onclick="closeRandomModal()">
                        å…³é—­ (ESC)
                    </button>
                </div>
            `;

            // è®°å½•å·²å­¦ä¹ çš„å•è¯
            learnedWords.add(randomWord.dutch);
            StorageManager.saveLearnedWords();
            updateStats();
        }

        // è·å–å½“å‰ç­›é€‰çš„å•è¯
        function getFilteredWords() {
            let filtered = vocabulary;

            if (currentFilter !== 'all') {
                filtered = filtered.filter(word => word.theme == currentFilter);
            }

            if (currentLetter !== 'all') {
                filtered = filtered.filter(word => word.dutch[0].toUpperCase() === currentLetter);
            }

            const searchTerm = document.getElementById('searchBox').value.toLowerCase();
            if (searchTerm) {
                filtered = filtered.filter(word =>
                    word.dutch.toLowerCase().includes(searchTerm) ||
                    word.english.toLowerCase().includes(searchTerm)
                );
            }

            return filtered.length > 0 ? filtered : vocabulary;
        }


        // åˆå§‹åŒ–äº‹ä»¶å¤„ç†
        function initRandomModal() {
            const modal = document.getElementById('randomModal');

            // äº‹ä»¶å§”æ‰˜å¤„ç†æ¨¡æ€æ¡†å†…çš„ç‚¹å‡»äº‹ä»¶
            modal.addEventListener('click', function(e) {
                // å¦‚æœæ¨¡æ€æ¡†æœªæ‰“å¼€ï¼Œè¿”å›
                if (!modal.classList.contains('active')) return;

                const target = e.target;

                // ç‚¹å‡»æ¨¡æ€æ¡†èƒŒæ™¯å…³é—­
                if (target === modal) {
                    closeRandomModal();
                    return;
                }

                // å¤„ç†å…³é—­æŒ‰é’® (Ã—)
                if (target.id === 'modalCloseBtn' || target.classList.contains('modal-close')) {
                    e.stopPropagation();
                    closeRandomModal();
                    return;
                }

                // å¤„ç†å…³é—­æŒ‰é’®
                if (target.id === 'closeBtn') {
                    e.stopPropagation();
                    closeRandomModal();
                    return;
                }

                // å¤„ç†ä¸‹ä¸€ä¸ªå•è¯æŒ‰é’®
                if (target.id === 'nextWordBtn') {
                    e.stopPropagation();
                    showRandomWord();
                    return;
                }

                // å¤„ç†å‘éŸ³æŒ‰é’®
                if (target.classList.contains('speak-btn-modal')) {
                    e.stopPropagation();
                    // onclickå·²åœ¨HTMLä¸­å¤„ç†
                    return;
                }

                // å¤„ç†å¡ç‰‡ç‚¹å‡»ï¼ˆç¿»è½¬ï¼‰
                const card = target.closest('#currentRandomCard');
                if (card && !target.classList.contains('speak-btn-modal')) {
                    e.stopPropagation();
                    card.classList.toggle('flipped');
                    return;
                }
            });

            // é”®ç›˜å¿«æ·é”® - ç§»åˆ°modalå¤–éƒ¨ï¼Œç¡®ä¿å…¨å±€ç›‘å¬
        }

        // å…¨å±€é”®ç›˜äº‹ä»¶ç›‘å¬å™¨ï¼ˆåœ¨initRandomModalå¤–éƒ¨ï¼‰
        document.addEventListener('keydown', function(e) {
            // å¤„ç†è¯¦ç»†ä¿¡æ¯æ¨¡æ€æ¡†
            const detailModal = document.getElementById('detailModal');
            if (detailModal && detailModal.classList.contains('active')) {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    closeDetailModal();
                    return;
                }
            }

            // å¤„ç†éšæœºå­¦ä¹ æ¨¡æ€æ¡†
            const randomModal = document.getElementById('randomModal');
            if (randomModal && randomModal.classList.contains('active')) {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    closeRandomModal();
                } else if (e.key === ' ' || e.key === 'Enter') {
                    e.preventDefault();
                    const card = document.getElementById('currentRandomCard');
                    if (card) card.classList.toggle('flipped');
                } else if (e.key === 'ArrowRight' || e.key === 'ArrowLeft') {
                    e.preventDefault();
                    showRandomWord();
                }
            }
        });

        // åœ¨DOMContentLoadedæ—¶åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', initRandomModal);

        // ç­›é€‰åŠŸèƒ½
        function filterByTheme(theme) {
            document.querySelectorAll('#themeFilters .filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            currentFilter = theme;
            displayVocabulary();
            StorageManager.savePreferences();
        }

        function filterByLetter(letter) {
            document.querySelectorAll('#letterFilters .filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            currentLetter = letter;
            displayVocabulary();
            StorageManager.savePreferences();
        }

        // æ¨¡å¼åˆ‡æ¢
        function setupEventListeners() {
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.onclick = function() {
                    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentMode = this.dataset.mode;

                    document.getElementById('cardsView').style.display = currentMode === 'list' ? 'none' : 'grid';
                    document.getElementById('listView').style.display = currentMode === 'list' ? 'block' : 'none';

                    displayVocabulary();
                    StorageManager.savePreferences();
                };
            });

            // ä½¿ç”¨é˜²æŠ–ä¼˜åŒ–æœç´¢
            const debouncedSearch = debounce(displayVocabulary, 300);
            document.getElementById('searchBox').addEventListener('input', debouncedSearch);
        }

        // æ›´æ–°ç»Ÿè®¡
        function updateStats() {
            document.getElementById('totalWords').textContent = vocabulary.length;
            document.getElementById('learnedWords').textContent = learnedWords.size;
            const progress = Math.round((learnedWords.size / vocabulary.length) * 100);
            document.getElementById('progress').textContent = progress + '%';
        }

        // å·¥å…·å‡½æ•°
        function clearSearch() {
            document.getElementById('searchBox').value = '';
            displayVocabulary();
        }

        function shuffleWords() {
            vocabulary.sort(() => Math.random() - 0.5);
            displayVocabulary();
        }

        function resetProgress() {
            if (confirm('ç¡®å®šè¦é‡ç½®å­¦ä¹ è¿›åº¦å—ï¼Ÿ')) {
                learnedWords.clear();
                StorageManager.saveLearnedWords();
                updateStats();

                // ç§»é™¤å·²å­¦ä¹ æ ·å¼
                document.querySelectorAll('.word-card.learned').forEach(card => {
                    card.classList.remove('learned');
                });

                displayVocabulary();
            }
        }

        // æ•°æ®å¯¼å…¥å¯¼å‡ºåŠŸèƒ½
        function exportData() {
            const exportObj = {
                version: '1.0',
                exportDate: new Date().toISOString(),
                learnedWords: [...learnedWords],
                preferences: {
                    filterTheme: currentFilter,
                    filterLetter: currentLetter,
                    viewMode: currentMode
                },
                statistics: {
                    totalWords: vocabulary.length,
                    learnedCount: learnedWords.size,
                    progress: Math.round((learnedWords.size / vocabulary.length) * 100)
                }
            };

            const dataStr = JSON.stringify(exportObj, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);

            const link = document.createElement('a');
            link.href = url;
            link.download = `dutch-vocabulary-progress-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            alert('å­¦ä¹ è¿›åº¦å·²å¯¼å‡ºï¼');
        }

        function importData() {
            document.getElementById('importFile').click();
        }

        function handleImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importObj = JSON.parse(e.target.result);

                    // éªŒè¯æ•°æ®æ ¼å¼
                    if (!importObj.version || !importObj.learnedWords) {
                        throw new Error('æ— æ•ˆçš„å¯¼å…¥æ–‡ä»¶æ ¼å¼');
                    }

                    // å¯¼å…¥å­¦ä¹ è¿›åº¦
                    learnedWords = new Set(importObj.learnedWords);
                    StorageManager.saveLearnedWords();

                    // å¯¼å…¥åå¥½è®¾ç½®
                    if (importObj.preferences) {
                        currentFilter = importObj.preferences.filterTheme || 'all';
                        currentLetter = importObj.preferences.filterLetter || 'all';
                        currentMode = importObj.preferences.viewMode || 'cards';
                        StorageManager.savePreferences();
                    }

                    // æ¢å¤ç•Œé¢çŠ¶æ€
                    restoreFilterStates();
                    updateStats();
                    displayVocabulary();

                    alert(`æˆåŠŸå¯¼å…¥å­¦ä¹ è¿›åº¦ï¼\nå·²å­¦ä¹ å•è¯ï¼š${learnedWords.size} ä¸ª`);
                } catch (error) {
                    alert('å¯¼å…¥å¤±è´¥ï¼š' + error.message);
                }

                // æ¸…ç©ºæ–‡ä»¶è¾“å…¥
                event.target.value = '';
            };

            reader.readAsText(file);
        }

        // å¯åŠ¨åº”ç”¨
        init();
    </script>
</body>
</html>